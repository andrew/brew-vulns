# frozen_string_literal: true

require "purl"
require "vers"

module Brew
  module Vulns
    class Vulnerability
      attr_reader :id, :summary, :details, :severity, :aliases, :references, :affected

      def initialize(data)
        @id = data["id"]
        @summary = data["summary"]
        @details = data["details"]
        @aliases = data["aliases"] || []
        @references = data["references"] || []
        @affected = data["affected"] || []
        @severity = extract_severity(data)
      end

      def severity_display
        severity&.upcase || "UNKNOWN"
      end

      def severity_level
        case severity&.downcase
        when "critical" then 4
        when "high" then 3
        when "medium" then 2
        when "low" then 1
        else 0
        end
      end

      def cve_ids
        ([id] + aliases).select { |a| a.start_with?("CVE-") }
      end

      def advisory_url
        ref = references.find { |r| r["type"] == "ADVISORY" }
        ref&.dig("url")
      end

      def fix_urls
        references.select { |r| r["type"] == "FIX" }.map { |r| r["url"] }
      end

      def fixed_versions
        versions = []
        affected.each do |aff|
          (aff["ranges"] || []).each do |range|
            (range["events"] || []).each do |event|
              versions << event["fixed"] if event["fixed"]
            end
          end
        end
        versions.uniq
      end

      def affects_version?(version, default_ecosystem = "gem")
        return true if affected.empty?

        normalized_version = normalize_version(version)

        affected.any? do |aff|
          ecosystem = extract_ecosystem(aff, default_ecosystem)

          in_explicit_versions?(aff, normalized_version) ||
            in_semver_ranges?(aff, normalized_version, ecosystem)
        end
      end

      def self.from_osv_list(vulns_data)
        vulns_data.map { |data| new(data) }
      end

      def extract_severity(data)
        if data["severity"]&.any?
          sev = data["severity"].first
          if sev["score"]&.include?("CVSS")
            return severity_from_cvss(sev["score"])
          end
        end

        if data.dig("database_specific", "severity")
          return normalize_severity(data.dig("database_specific", "severity"))
        end

        data["affected"]&.each do |aff|
          eco_sev = aff.dig("ecosystem_specific", "severity")
          return normalize_severity(eco_sev) if eco_sev

          db_sev = aff.dig("database_specific", "severity")
          return normalize_severity(db_sev) if db_sev
        end

        nil
      end

      def normalize_severity(severity)
        return nil unless severity

        case severity.downcase
        when "critical" then "critical"
        when "high" then "high"
        when "moderate", "medium" then "medium"
        when "low" then "low"
        end
      end

      def severity_from_cvss(vector)
        return nil unless vector
        return nil unless vector.include?("CVSS:3")

        metrics = parse_cvss_metrics(vector)
        return nil if metrics.empty?

        impact_high = %w[C I A].count { |m| metrics[m] == "H" }
        network_attack = metrics["AV"] == "N"
        no_privs = metrics["PR"] == "N"
        no_interaction = metrics["UI"] == "N"

        if impact_high >= 2 && network_attack && no_privs
          "critical"
        elsif impact_high >= 1 && network_attack
          "high"
        elsif impact_high >= 1 || (network_attack && no_privs && no_interaction)
          "medium"
        else
          "low"
        end
      end

      def parse_cvss_metrics(vector)
        metrics = {}
        vector.scan(%r{([A-Z]+):([A-Z])}).each do |key, value|
          metrics[key] = value
        end
        metrics
      end

      def normalize_version(version)
        version.sub(/^v/, "")
      end

      def extract_ecosystem(aff, default_ecosystem)
        purl_str = aff.dig("package", "purl")
        return default_ecosystem unless purl_str

        purl = Purl.parse(purl_str)
        purl.type
      rescue StandardError => e
        warn "Warning: Failed to parse purl '#{purl_str}': #{e.message}"
        default_ecosystem
      end

      def in_explicit_versions?(aff, version)
        versions = aff["versions"] || []
        versions.any? { |v| normalize_version(v) == version }
      end

      def in_semver_ranges?(aff, version, ecosystem)
        ranges = aff["ranges"] || []
        semver_ranges = ranges.select { |r| r["type"] == "SEMVER" }

        semver_ranges.any? do |range|
          version_in_range?(version, range["events"], ecosystem)
        end
      end

      def version_in_range?(version, events, ecosystem)
        return false if events.nil? || events.empty?

        constraints = build_constraints(events)
        return false if constraints.empty?

        Vers.satisfies?(version, constraints.join(","), ecosystem)
      rescue StandardError => e
        warn "Warning: Failed to check version '#{version}' against constraints: #{e.message}"
        false
      end

      def build_constraints(events)
        constraints = []
        events.each do |event|
          if event["introduced"]
            intro = normalize_version(event["introduced"])
            constraints << ">=#{intro}" unless intro == "0"
          end
          if event["fixed"]
            constraints << "<#{normalize_version(event["fixed"])}"
          end
          if event["last_affected"]
            constraints << "<=#{normalize_version(event["last_affected"])}"
          end
        end
        constraints
      end
    end
  end
end
